import { 
  doc, 
  setDoc, 
  getDoc, 
  updateDoc, 
  deleteDoc, 
  collection,
  query,
  where,
  getDocs,
  serverTimestamp,
  onSnapshot,
  orderBy,
  writeBatch,
  increment,
  arrayUnion,
  limit,
  deleteField
} from 'firebase/firestore';
import { db } from './firebase';
import { auth } from './firebase';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth';

// User Operations
const createUserProfile = async (userId, userData) => {
  try {
    const userRef = doc(db, 'users', userId);
    
    // Handle both nested and flat profile data structures
    const email = userData.profile?.email || userData.email;
    const displayName = userData.profile?.displayName || userData.displayName || email?.split('@')[0] || 'User';
    const photoURL = userData.profile?.photoURL || userData.photoURL || null;
    const phoneNumber = userData.profile?.phoneNumber || userData.phoneNumber || null;
    const bio = userData.profile?.bio || userData.bio || '';
    const location = userData.profile?.location || userData.location || null;

    const profileData = {
      profile: {
        email,
        displayName,
        photoURL,
        phoneNumber,
        bio,
        location,
        setupComplete: false,
        social: {
          interests: [],
          preferredRoutes: [],
          availability: {
            monday: [],
            tuesday: [],
            wednesday: [],
            thursday: [],
            friday: [],
            saturday: [],
            sunday: []
          }
        }
      },
      
      // Settings and preferences
      settings: {
        privacy: {
          profileVisibility: 'friends',
          showOnlineStatus: true,
          showRideHistory: true,
          allowRideInvites: true,
          allowFriendRequests: true,
          allowCommunityInvites: true
        },
        notifications: {
          friendRequests: true,
          rideInvites: true,
          communityUpdates: true,
          friendActivity: true
        },
        ridePreferences: {
          music: true,
          conversation: true,
          carType: 'any',
          smoking: false,
          pets: false,
          maxPassengers: 4
        }
      },
      
      // Trust and reputation
      reputation: {
        trustScore: 0,
        rideCount: 0,
        rating: 0,
        badges: [],
        verification: {
          email: true,
          phone: false
        }
      },
      
      // Metadata
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    await setDoc(userRef, profileData);
    return { success: true, profile: profileData };
  } catch (error) {
    console.error('Error creating user profile:', error);
    return { success: false, error };
  }
};

const updateUserProfile = async (userId, userData) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      ...userData,
      updatedAt: serverTimestamp()
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating user profile:', error);
    return { success: false, error };
  }
};

// Group Operations
const createGroup = async (groupData) => {
  try {
    const groupRef = doc(collection(db, 'groups'));
    await setDoc(groupRef, {
      ...groupData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    return { success: true, groupId: groupRef.id };
  } catch (error) {
    console.error('Error creating group:', error);
    return { success: false, error };
  }
};

const updateGroup = async (groupId, groupData) => {
  try {
    const groupRef = doc(db, 'groups', groupId);
    await updateDoc(groupRef, {
      ...groupData,
      updatedAt: serverTimestamp()
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating group:', error);
    return { success: false, error };
  }
};

// Generate a unique ride ID
const generateRideId = async () => {
  try {
    // Get the latest ride ID from a counter document
    const counterRef = doc(db, 'counters', 'rideIds');
    const counterDoc = await getDoc(counterRef);
    
    let nextId;
    if (!counterDoc.exists()) {
      // Initialize counter if it doesn't exist
      nextId = 1;
      await setDoc(counterRef, { count: nextId });
    } else {
      // Increment the counter
      nextId = counterDoc.data().count + 1;
      await updateDoc(counterRef, { count: increment(1) });
    }
    
    // Format the ID as RIDE-XXXX
    return `RIDE-${nextId.toString().padStart(4, '0')}`;
  } catch (error) {
    console.error('Error generating ride ID:', error);
    throw error;
  }
};

// Update the createRide function to use friendly ride ID as document ID
const createRide = async (rideData) => {
  try {
    // Generate a user-friendly ride ID
    const rideId = await generateRideId();
    
    // Use the friendly ride ID as the document ID
    const rideRef = doc(db, 'rides', rideId);
    
    // Calculate initial route details
    const routeDetails = {
      optimizedRoute: null, // Will be calculated when the ride starts
      pickupOrder: [], // Will be populated with optimized pickup order
      estimatedTimes: {
        totalDuration: null, // Total estimated duration in minutes
        totalDistance: null, // Total distance in kilometers
        pickupTimes: {}, // Map of passenger tempId to estimated pickup time
        arrivalTime: null // Estimated arrival time at destination
      },
      waypoints: [], // Array of waypoints including pickup locations and destination
      lastUpdated: null // Timestamp of last route update
    };

    // Create the ride document with enhanced data structure
    await setDoc(rideRef, {
      ...rideData,
      rideId, // Store the ID as a field for easy access
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      routeDetails,
      // Add passengerUids array for easier querying
      passengerUids: rideData.passengers.map(p => p.uid).filter(Boolean),
      // Add status tracking
      status: 'created', // 'created', 'active', 'completed', 'cancelled'
      statusHistory: [{
        status: 'created',
        timestamp: new Date().toISOString(),
        updatedBy: rideData.driver?.uid || null
      }],
      // Add metadata
      metadata: {
        isOptimized: false,
        optimizationAttempts: 0,
        lastOptimizationAttempt: null,
        optimizationStatus: 'pending', // 'pending', 'in_progress', 'completed', 'failed'
        optimizationError: null
      }
    });

    return { 
      success: true, 
      rideId,
      message: `Ride created successfully! Your ride ID is: ${rideId}`
    };
  } catch (error) {
    console.error('Error creating ride:', error);
    return { success: false, error };
  }
};

const updateRide = async (rideId, rideData) => {
  try {
    const rideRef = doc(db, 'rides', rideId);
    await updateDoc(rideRef, {
      ...rideData,
      updatedAt: serverTimestamp()
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating ride:', error);
    return { success: false, error };
  }
};

// Participant Operations
const updateRideParticipation = async (rideId, userId, status) => {
  try {
    const rideRef = doc(db, 'rides', rideId);
    await updateDoc(rideRef, {
      [`participants.${userId}`]: {
        status,
        updatedAt: serverTimestamp()
      }
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating ride participation:', error);
    return { success: false, error };
  }
};

// Location Operations
const updateUserLocation = async (userId, location) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      location: {
        ...location,
        lastUpdated: serverTimestamp()
      }
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating user location:', error);
    return { success: false, error };
  }
};

// Message Operations
const sendMessage = async (groupId, messageData) => {
  try {
    const messageRef = doc(collection(db, 'messages'));
    await setDoc(messageRef, {
      ...messageData,
      groupId,
      createdAt: serverTimestamp()
    });
    return { success: true, messageId: messageRef.id };
  } catch (error) {
    console.error('Error sending message:', error);
    return { success: false, error };
  }
};

// Notification Operations
const createNotification = async (notificationData) => {
  try {
    if (!notificationData.userId) {
      throw new Error('userId is required for notification');
    }

    const notificationRef = doc(collection(db, 'notifications'));
    await setDoc(notificationRef, {
      ...notificationData,
      isRead: false,
      createdAt: serverTimestamp()
    });
    return { success: true, notificationId: notificationRef.id };
  } catch (error) {
    console.error('Error creating notification:', error);
    return { success: false, error };
  }
};

// Helper function to generate a consistent friendship ID
const generateFriendshipId = (userId1, userId2) => {
  // Sort the user IDs to ensure consistent friendship ID regardless of who initiated
  const sortedIds = [userId1, userId2].sort();
  return `${sortedIds[0]}_${sortedIds[1]}`;
};

// Friend Operations
const sendFriendRequest = async ({ senderId, receiverId, message }) => {
  try {
    console.log('\n=== sendFriendRequest START ===');
    console.log('Initial Parameters:', { senderId, receiverId, message });

    // 1. Check authentication
    const auth = getAuth();
    const user = auth.currentUser;
    console.log('Authentication State:', {
      isAuthenticated: !!user,
      authUserId: user?.uid,
      email: user?.email,
      token: user ? 'Present' : 'Missing',
      authUid: user?.uid,
      auth: user
    });

    if (!user) {
      throw new Error('User must be authenticated to send friend requests');
    }

    // 2. Verify both users exist
    const senderDoc = await getDoc(doc(db, 'users', senderId));
    const receiverDoc = await getDoc(doc(db, 'users', receiverId));
    
    console.log('User Documents Check:', {
      senderExists: senderDoc.exists(),
      receiverExists: receiverDoc.exists(),
      senderId,
      receiverId
    });

    if (!senderDoc.exists() || !receiverDoc.exists()) {
      throw new Error('One or both users do not exist');
    }

    // 3. Check receiver's privacy settings
    const receiverData = receiverDoc.data();
    const privacySettings = receiverData.settings?.privacy || {};
    console.log('Receiver Privacy Settings:', {
      allowFriendRequests: privacySettings.allowFriendRequests !== false,
      settings: privacySettings
    });

    if (privacySettings.allowFriendRequests === false) {
      throw new Error('This user is not accepting friend requests');
    }

    // 4. Check for existing requests
    const existingRequestsQuery = query(
      collection(db, 'friendRequests'),
      where('senderId', '==', senderId),
      where('receiverId', '==', receiverId),
      where('metadata.status', '==', 'pending')  // Only check for pending requests
    );

    const existingRequests = await getDocs(existingRequestsQuery);
    console.log('Existing Requests Check:', {
      hasExistingRequests: !existingRequests.empty,
      count: existingRequests.size,
      status: 'Only checking for pending requests'
    });

    if (!existingRequests.empty) {
      throw new Error('A pending friend request already exists between these users');
    }

    // 5. Prepare the friend request data
    const senderData = senderDoc.data();
    const friendRequestData = {
      senderId,
      receiverId,
      senderProfile: {
        displayName: senderData.profile?.displayName || 'Anonymous User',
        photoURL: senderData.profile?.photoURL || '',
        email: senderData.profile?.email || user.email || ''
      },
      message,
      metadata: {
        status: 'pending',
        createdBy: senderId
      }
    };

    console.log('\n5. Final Data Being Sent:');
    console.log(JSON.stringify(friendRequestData, null, 2));

    // 6. Log the Firestore rule evaluation context
    console.log('\n7. Firestore Rule Evaluation Context:');
    console.log('request.auth:', {
      uid: user.uid,
      token: 'Present'
    });

    // 7. Log the exact data being sent to Firestore
    console.log('\n8. Exact Data Being Sent to Firestore:');
    const validation = {
      basic: {
        hasData: true,
        hasSenderId: typeof friendRequestData.senderId === 'string',
        hasReceiverId: typeof friendRequestData.receiverId === 'string',
        hasMetadata: typeof friendRequestData.metadata === 'object',
        hasMessage: typeof friendRequestData.message === 'string',
        hasSenderProfile: typeof friendRequestData.senderProfile === 'object'
      },
      metadata: {
        hasStatus: friendRequestData.metadata.status === 'pending',
        isPending: friendRequestData.metadata.status === 'pending',
        hasCreatedBy: typeof friendRequestData.metadata.createdBy === 'string'
      },
      profile: {
        hasDisplayName: typeof friendRequestData.senderProfile.displayName === 'string',
        hasEmail: typeof friendRequestData.senderProfile.email === 'string',
        hasValidPhotoURL: typeof friendRequestData.senderProfile.photoURL === 'string'
      },
      auth: {
        isAuthenticated: !!user,
        senderMatchesAuth: user.uid === senderId,
        notSelfRequest: senderId !== receiverId
      }
    };

    console.log(JSON.stringify({
      path: `friendRequests/${doc(collection(db, 'friendRequests')).id}`,
      data: friendRequestData,
      validation
    }, null, 2));

    // 8. Create the friend request
    const friendRequestRef = doc(collection(db, 'friendRequests'));
    await setDoc(friendRequestRef, friendRequestData);

    return {
      success: true,
      requestId: friendRequestRef.id,
      data: friendRequestData
    };

  } catch (error) {
    console.error('\nError Details:', {
      code: error.code,
      message: error.message,
      ruleValidation: error.ruleValidation,
      auth: error.auth,
      request: error.request
    });
    
    throw {
      error,
      code: error.code,
      message: error.message,
      senderId,
      receiverId,
      timestamp: new Date().toISOString()
    };
  }
};

const updateFriendRequest = async (requestId, status) => {
  console.log('=== updateFriendRequest START ===');
  console.log('Initial Parameters:', { requestId, status });
  
  let userId;
  
  try {
    const authUser = auth.currentUser;
    if (!authUser) {
      console.error('No authenticated user found');
      throw new Error('User not authenticated');
    }

    userId = authUser.uid;
    console.log('=== Friend Request Update Debug ===');
    console.log('Authentication State:', {
      isAuthenticated: true,
      authUserId: userId,
      email: authUser.email,
      token: authUser.accessToken ? 'Present' : 'Missing',
      authUid: authUser.uid
    });

    const requestRef = doc(db, 'friendRequests', requestId);
    const requestDoc = await getDoc(requestRef);
    
    if (!requestDoc.exists()) {
      console.error('Request not found:', requestId);
      throw new Error('Friend request not found');
    }

    let requestData = requestDoc.data();
    
    // If this is an old document structure, migrate it first
    if ('status' in requestData && (!('metadata' in requestData) || !requestData.metadata?.status)) {
      console.log('Migrating old document structure to new format');
      const migrationUpdate = {
        metadata: {
          status: requestData.status,
          createdAt: requestData.createdAt || new Date().toISOString(),
          createdBy: requestData.senderId,
          updatedAt: new Date().toISOString(),
          updatedBy: userId
        }
      };
      
      // Remove the old status field
      await updateDoc(requestRef, {
        ...migrationUpdate,
        status: deleteField()
      });
      
      // Refresh the document data after migration
      const updatedDoc = await getDoc(requestRef);
      if (!updatedDoc.exists()) {
        throw new Error('Document disappeared after migration');
      }
      requestData = updatedDoc.data();
    }

    // Log the document structure after migration
    console.log('Friend Request Document Structure:', {
      id: requestId,
      fullData: requestData,
      hasMetadata: 'metadata' in requestData,
      metadataStatus: requestData.metadata?.status,
      allFields: Object.keys(requestData)
    });

    if (!requestData.metadata?.status) {
      console.error('Invalid document structure after migration:', requestData);
      throw new Error('Invalid friend request document structure');
    }

    console.log('Current Request State:', {
      id: requestId,
      senderId: requestData.senderId,
      receiverId: requestData.receiverId,
      currentStatus: requestData.metadata.status,
      attemptedStatus: status,
      metadata: requestData.metadata,
      authUserId: userId,
      isReceiverMatch: requestData.receiverId === userId,
      isStatusPending: requestData.metadata.status === 'pending',
      isStatusChange: status !== requestData.metadata.status,
      isStatusValid: ['accepted', 'rejected'].includes(status)
    });

    // Verify all conditions required by Firestore rules
    const ruleChecks = {
      isAuthenticated: true,
      isReceiver: requestData.receiverId === userId,
      isPending: requestData.metadata.status === 'pending',
      isValidStatus: ['accepted', 'rejected'].includes(status),
      isStatusChange: status !== requestData.metadata.status
    };

    console.log('Firestore Rule Checks:', {
      ...ruleChecks,
      ruleCheckDetails: {
        isAuthenticated: 'User must be authenticated',
        isReceiver: `User ID (${userId}) must match receiver ID (${requestData.receiverId})`,
        isPending: `Current status (${requestData.metadata.status}) must be 'pending'`,
        isValidStatus: `New status (${status}) must be 'accepted' or 'rejected'`,
        isStatusChange: `New status (${status}) must be different from current status (${requestData.metadata.status})`
      }
    });

    // Check each condition and log which one fails
    if (!ruleChecks.isReceiver) {
      console.error('Rule Check Failed: User is not the receiver', {
        userId,
        receiverId: requestData.receiverId,
        authUid: authUser.uid,
        isMatch: requestData.receiverId === userId
      });
      throw new Error('Unauthorized: Only the receiver can update the request');
    }
    if (!ruleChecks.isPending) {
      console.error('Rule Check Failed: Request is not pending', {
        currentStatus: requestData.metadata.status,
        expectedStatus: 'pending'
      });
      throw new Error('Cannot update: Request is no longer pending');
    }
    if (!ruleChecks.isValidStatus) {
      console.error('Rule Check Failed: Invalid status', {
        attemptedStatus: status,
        allowedStatuses: ['accepted', 'rejected']
      });
      throw new Error('Invalid status: Must be accepted or rejected');
    }
    if (!ruleChecks.isStatusChange) {
      console.error('Rule Check Failed: Status not changing', {
        currentStatus: requestData.metadata.status,
        attemptedStatus: status
      });
      throw new Error('Status must change');
    }

    // Update metadata with new status
    const metadataUpdate = {
      metadata: {
        ...requestData.metadata,
        status,
        updatedAt: new Date().toISOString(),
        updatedBy: userId
      }
    };

    console.log('Attempting Update:', {
      requestRef: requestRef.path,
      metadataUpdate,
      authUser: {
        uid: userId,
        email: authUser.email,
        authUid: authUser.uid
      }
    });

    await updateDoc(requestRef, metadataUpdate);
    console.log('Update Successful');

    // Handle side effects based on the new status
    if (status === 'accepted') {
      // Create friendship relationship
      const batch = writeBatch(db);
      
      // Get user data for notifications
      const [senderDoc, receiverDoc] = await Promise.all([
        getDoc(doc(db, 'users', requestData.senderId)),
        getDoc(doc(db, 'users', requestData.receiverId))
      ]);

      if (!senderDoc.exists() || !receiverDoc.exists()) {
        throw new Error('User profiles not found');
      }

      const senderData = senderDoc.data();
      const receiverData = receiverDoc.data();

      // Create friendship documents using the helper function
      const friendshipId = generateFriendshipId(requestData.senderId, requestData.receiverId);
      const friendshipRef = doc(db, 'relationships', friendshipId);
      
      batch.set(friendshipRef, {
        users: [requestData.senderId, requestData.receiverId],
        type: 'friend',
        status: 'active',
        metadata: {
          createdAt: new Date().toISOString(),
          createdBy: userId,
          updatedAt: new Date().toISOString(),
          updatedBy: userId,
          lastInteraction: new Date().toISOString()
        }
      });

      // Create notifications
      const senderNotificationRef = doc(collection(db, 'notifications'));
      const receiverNotificationRef = doc(collection(db, 'notifications'));

      batch.set(senderNotificationRef, {
        userId: requestData.senderId,
        type: 'friend_request_accepted',
        title: 'Friend Request Accepted',
        message: `${receiverData.profile.displayName} accepted your friend request`,
        metadata: {
          status: 'unread',
          createdAt: new Date().toISOString(),
          createdBy: userId,
          updatedAt: new Date().toISOString(),
          updatedBy: userId
        }
      });

      batch.set(receiverNotificationRef, {
        userId: requestData.receiverId,
        type: 'friend_request_accepted',
        title: 'Friend Request Accepted',
        message: `You accepted ${senderData.profile.displayName}'s friend request`,
        metadata: {
          status: 'unread',
          createdAt: new Date().toISOString(),
          createdBy: userId,
          updatedAt: new Date().toISOString(),
          updatedBy: userId
        }
      });

      await batch.commit();
      console.log('Successfully created friendship and notifications');
    } else if (status === 'rejected') {
      // Notify the sender about rejection
      const senderDoc = await getDoc(doc(db, 'users', requestData.senderId));
      if (!senderDoc.exists()) {
        throw new Error('Sender profile not found');
      }

      const senderData = senderDoc.data();
      const receiverDoc = await getDoc(doc(db, 'users', requestData.receiverId));
      const receiverData = receiverDoc.data();

      const notificationRef = doc(collection(db, 'notifications'));
      await setDoc(notificationRef, {
        userId: requestData.senderId,
        type: 'friend_request_rejected',
        title: 'Friend Request Rejected',
        message: `${receiverData.profile.displayName} rejected your friend request`,
        metadata: {
          status: 'unread',
          createdAt: new Date().toISOString(),
          createdBy: userId,
          updatedAt: new Date().toISOString(),
          updatedBy: userId
        }
      });
      console.log('Successfully created rejection notification');
    }

    return { success: true, message: `Friend request ${status}` };
  } catch (error) {
    console.error('Error updating friend request:', {
      error,
      code: error.code,
      message: error.message,
      requestId,
      status,
      userId: userId || 'not set',
      authContext: auth.currentUser ? {
        uid: auth.currentUser.uid,
        email: auth.currentUser.email
      } : 'No auth user',
      timestamp: new Date().toISOString()
    });
    throw error;
  }
};

const getFriendsList = async (userId) => {
  try {
    // Get active friendships where user is a participant
    const relationshipsQuery = query(
      collection(db, 'relationships'),
      where('users', 'array-contains', userId),
      where('status', '==', 'active'),
      where('type', '==', 'friend')
    );

    const relationshipsSnapshot = await getDocs(relationshipsQuery);
    const friendIds = relationshipsSnapshot.docs.map(doc => {
      const data = doc.data();
      return data.users.find(id => id !== userId);
    });

    // Get friend profiles
    const friendProfiles = await Promise.all(
      friendIds.map(async (friendId) => {
        const userDoc = await getDoc(doc(db, 'users', friendId));
        const userData = userDoc.data();
        const relationship = relationshipsSnapshot.docs.find(doc => 
          doc.data().users.includes(friendId)
        ).data();

        return {
          id: friendId,
          profile: userData.profile,
          relationship: {
            id: relationship.id,
            communityId: relationship.metadata.communityId,
            communityRole: relationship.metadata.communityRole,
            addedAt: relationship.metadata.createdAt,
            lastInteraction: relationship.metadata.lastInteraction
          },
          isOnline: userData.isOnline,
          lastSeen: userData.lastSeen
        };
      })
    );

    return {
      success: true,
      friends: friendProfiles
    };
  } catch (error) {
    console.error('Error getting friends list:', error);
    return { success: false, error };
  }
};

const updateRelationshipCommunity = async (relationshipId, communityId, communityRole, userId) => {
  try {
    const relationshipRef = doc(db, 'relationships', relationshipId);
    const relationshipDoc = await getDoc(relationshipRef);
    
    if (!relationshipDoc.exists()) {
      throw new Error('Relationship not found');
    }

    const relationshipData = relationshipDoc.data();
    
    // Verify user is part of the relationship
    if (!relationshipData.users.includes(userId)) {
      throw new Error('Not authorized to update this relationship');
    }

    // Get the other user's ID for notification
    const otherUserId = relationshipData.users.find(id => id !== userId);
    
    // Update relationship
    await updateDoc(relationshipRef, {
      'metadata.communityId': communityId,
      'metadata.communityRole': communityRole,
      'metadata.lastInteraction': serverTimestamp()
    });

    // Get user profiles for notifications
    const [userDoc, otherUserDoc] = await Promise.all([
      getDoc(doc(db, 'users', userId)),
      getDoc(doc(db, 'users', otherUserId))
    ]);

    // Create notifications for both users
    await Promise.all([
      createNotification({
        userId: otherUserId,
        type: 'community_update',
        title: 'Community Update',
        message: communityId 
          ? `${userDoc.data().profile.displayName} added you to a community`
          : `${userDoc.data().profile.displayName} removed you from a community`,
        data: {
          relationshipId,
          communityId,
          communityRole,
          updatedBy: userId,
          updatedByName: userDoc.data().profile.displayName
        }
      }),
      createNotification({
        userId,
        type: 'community_update',
        title: 'Community Update',
        message: communityId
          ? `You added ${otherUserDoc.data().profile.displayName} to a community`
          : `You removed ${otherUserDoc.data().profile.displayName} from a community`,
        data: {
          relationshipId,
          communityId,
          communityRole,
          otherUserId,
          otherUserName: otherUserDoc.data().profile.displayName
        }
      })
    ]);

    return { success: true };
  } catch (error) {
    console.error('Error updating relationship community:', error);
    return { success: false, error };
  }
};

const removeFriendship = async (userId, friendId) => {
  try {
    const relationshipQuery = query(
      collection(db, 'relationships'),
      where('users', 'array-contains', userId),
      where('status', '==', 'active'),
      where('type', '==', 'friend')
    );

    const relationshipSnapshot = await getDocs(relationshipQuery);
    if (relationshipSnapshot.empty) {
      throw new Error('Friendship not found');
    }

    const relationshipDoc = relationshipSnapshot.docs[0];
    const relationshipData = relationshipDoc.data();

    // Update relationship status
    await updateDoc(relationshipDoc.ref, {
      status: 'removed',
      'metadata.removedAt': serverTimestamp(),
      'metadata.removedBy': userId
    });

    // Get user profiles for notifications
    const [userDoc, friendDoc] = await Promise.all([
      getDoc(doc(db, 'users', userId)),
      getDoc(doc(db, 'users', friendId))
    ]);

    // Create notifications
    await Promise.all([
      createNotification({
        userId: friendId,
        type: 'friend_removed',
        title: 'Friend Removed',
        message: `${userDoc.data().profile.displayName} removed you from their friends`,
        data: {
          userId,
          userName: userDoc.data().profile.displayName
        }
      }),
      createNotification({
        userId,
        type: 'friend_removed',
        title: 'Friend Removed',
        message: `You removed ${friendDoc.data().profile.displayName} from your friends`,
        data: {
          friendId,
          friendName: friendDoc.data().profile.displayName
        }
      })
    ]);

    return { success: true };
  } catch (error) {
    console.error('Error removing friendship:', error);
    return { success: false, error };
  }
};

// Search Operations
const searchUsers = async (searchTerm) => {
  try {
    if (!searchTerm.trim()) {
      return { success: true, users: [] };
    }

    const usersRef = collection(db, 'users');
    const searchTermLower = searchTerm.toLowerCase().trim();
    
    // Get all users and filter client-side for more flexible matching
    const snapshot = await getDocs(usersRef);
    const users = snapshot.docs
      .map(doc => ({
        id: doc.id,
        ...doc.data()
      }))
      .filter(user => {
        // Get displayName and email from profile object for Google sign-in users
        const displayName = (user.profile?.displayName || user.displayName || '').toLowerCase();
        const email = (user.profile?.email || user.email || '').toLowerCase();
        
        console.log('Searching user:', {
          id: user.id,
          displayName,
          email,
          hasProfile: !!user.profile,
          profileData: user.profile
        });
        
        // Check for exact matches first
        if (displayName === searchTermLower || email === searchTermLower) {
          return true;
        }
        
        // Then check for partial matches
        return displayName.includes(searchTermLower) || 
               email.includes(searchTermLower);
      });

    return {
      success: true,
      users
    };
  } catch (error) {
    console.error('Error searching users:', error);
    return { success: false, error };
  }
};

// Real-time Friend Operations
const subscribeToFriendRequests = (userId, callback) => {
  try {
    // Query using the new metadata structure
    const requestsQuery = query(
      collection(db, 'friendRequests'),
      where('receiverId', '==', userId),
      where('metadata.status', '==', 'pending')
    );

    // Return the unsubscribe function
    return onSnapshot(requestsQuery, 
      (snapshot) => {
        const requests = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        callback({ success: true, requests });
      },
      (error) => {
        console.error('Error in friend requests subscription:', error);
        callback({ success: false, error });
      }
    );
  } catch (error) {
    console.error('Error setting up friend requests subscription:', error);
    callback({ success: false, error });
    return () => {}; // Return empty unsubscribe function
  }
};

const subscribeToFriendsList = (userId, callback) => {
  if (!userId) {
    console.error('User ID is required for friends list subscription');
    callback({ success: false, error: 'User ID is required' });
    return () => {};
  }

  try {
    console.log('Setting up friends list subscription for user:', userId);
    const relationshipsQuery = query(
      collection(db, 'relationships'),
      where('users', 'array-contains', userId),
      where('status', '==', 'active'),
      where('type', '==', 'friend')
    );
    
    return onSnapshot(relationshipsQuery, 
      async (snapshot) => {
        try {
          console.log('Friends list snapshot received:', {
            size: snapshot.size,
            empty: snapshot.empty,
            metadata: snapshot.metadata
          });

          // Get all friend IDs from relationships
          const friendIds = snapshot.docs.map(doc => {
            const data = doc.data();
            // Validate document structure
            if (!data.users || !Array.isArray(data.users) || data.users.length !== 2) {
              console.error('Invalid relationship document structure:', doc.id);
              return null;
            }
            return data.users.find(id => id !== userId);
          }).filter(Boolean); // Remove any null values

          if (friendIds.length === 0) {
            callback({ success: true, friends: [] });
            return;
          }

          // Get friend profiles
          const friendProfiles = await Promise.all(
            friendIds.map(async (friendId) => {
              try {
                const userDoc = await getDoc(doc(db, 'users', friendId));
                if (!userDoc.exists()) {
                  console.log('Friend profile not found:', friendId);
                  return null;
                }

                const userData = userDoc.data();
                const relationship = snapshot.docs.find(doc => 
                  doc.data().users.includes(friendId)
                );

                if (!relationship) {
                  console.error('Relationship not found for friend:', friendId);
                  return null;
                }

                const relationshipData = relationship.data();
                // Validate relationship metadata
                if (!relationshipData.metadata || 
                    !relationshipData.metadata.createdAt || 
                    !relationshipData.metadata.lastInteraction) {
                  console.error('Invalid relationship metadata:', relationship.id);
                  return null;
                }

                return {
                  id: friendId,
                  profile: userData.profile || {
                    displayName: 'Unknown User',
                    email: null,
                    photoURL: null
                  },
                  relationship: {
                    id: relationship.id,
                    communityId: relationshipData.metadata.communityId || null,
                    communityRole: relationshipData.metadata.communityRole || null,
                    addedAt: relationshipData.metadata.createdAt,
                    lastInteraction: relationshipData.metadata.lastInteraction
                  },
                  isOnline: userData.isOnline || false,
                  lastSeen: userData.lastSeen || null
                };
              } catch (error) {
                console.error('Error fetching friend profile:', friendId, error);
                return null;
              }
            })
          );

          // Filter out any null profiles (deleted users or invalid data)
          const validFriends = friendProfiles.filter(profile => profile !== null);
          console.log('Friends list processed:', {
            total: friendIds.length,
            valid: validFriends.length
          });
          callback({ success: true, friends: validFriends });
        } catch (error) {
          console.error('Error processing friends list:', error);
          callback({ 
            success: false, 
            error: error.message || 'Failed to process friends list'
          });
        }
      },
      (error) => {
        console.error('Error in friends list subscription:', error);
        callback({ 
          success: false, 
          error: error.message || 'Failed to subscribe to friends list'
        });
      }
    );
  } catch (error) {
    console.error('Error setting up friends list subscription:', error);
    callback({ 
      success: false, 
      error: error.message || 'Failed to set up friends list subscription'
    });
    return () => {}; // Return empty unsubscribe function
  }
};

const subscribeToUserStatus = (userId, callback) => {
  try {
    const userRef = doc(db, 'users', userId);
    
    return onSnapshot(userRef,
      (doc) => {
        if (doc.exists()) {
          const userData = doc.data();
          callback({ 
            success: true, 
            status: {
              isOnline: userData.isOnline,
              lastSeen: userData.lastSeen
            }
          });
        } else {
          callback({ success: false, error: 'User not found' });
        }
      },
      (error) => {
        console.error('Error in user status subscription:', error);
        callback({ success: false, error });
      }
    );
  } catch (error) {
    console.error('Error setting up user status subscription:', error);
    callback({ success: false, error });
    return () => {}; // Return empty unsubscribe function
  }
};

// Update user's online status
const updateUserOnlineStatus = async (userId, isOnline) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      isOnline,
      lastSeen: serverTimestamp()
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating user online status:', error);
    return { success: false, error };
  }
};

// Add function to update user settings
const updateUserSettings = async (userId, settings) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      'settings': settings,
      updatedAt: serverTimestamp()
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating user settings:', error);
    return { success: false, error };
  }
};

// Add new function to update user reputation
const updateUserReputation = async (userId, reputationData) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      'reputation': reputationData,
      updatedAt: serverTimestamp()
    });
    return { success: true };
  } catch (error) {
    console.error('Error updating user reputation:', error);
    return { success: false, error };
  }
};

const checkFriendshipStatus = async (userId1, userId2) => {
  try {
    const relationshipsQuery = query(
      collection(db, 'relationships'),
      where('users', 'array-contains', userId1),
      where('status', '==', 'active'),
      where('type', '==', 'friend')
    );

    const snapshot = await getDocs(relationshipsQuery);
    const friendship = snapshot.docs.find(doc => {
      const data = doc.data();
      return data.users.includes(userId2);
    });

    return {
      success: true,
      areFriends: !!friendship,
      friendshipId: friendship?.id,
      metadata: friendship ? {
        communityId: friendship.data().metadata.communityId,
        communityRole: friendship.data().metadata.communityRole,
        lastInteraction: friendship.data().metadata.lastInteraction
      } : null
    };
  } catch (error) {
    console.error('Error checking friendship status:', error);
    return { success: false, error };
  }
};

// Add getUserRideHistory function
const getUserRideHistory = async (userId) => {
  try {
    // Calculate timestamp for 24 hours ago
    const twentyFourHoursAgo = new Date();
    twentyFourHoursAgo.setHours(twentyFourHoursAgo.getHours() - 24);

    // Query for rides where user is driver
    const driverQuery = query(
      collection(db, 'rides'),
      where('driver.uid', '==', userId),
      where('createdAt', '>=', twentyFourHoursAgo),
      orderBy('createdAt', 'desc')
    );

    // Query for rides where user is passenger
    const passengerQuery = query(
      collection(db, 'rides'),
      where('passengerUids', 'array-contains', userId),
      where('createdAt', '>=', twentyFourHoursAgo),
      orderBy('createdAt', 'desc')
    );

    // Get both driver and passenger rides
      const [driverSnapshot, passengerSnapshot] = await Promise.all([
        getDocs(driverQuery),
        getDocs(passengerQuery)
      ]);

    // Combine and process the results
    const rides = [
        ...driverSnapshot.docs.map(doc => ({ 
          id: doc.id, 
          ...doc.data(), 
        role: 'driver'
        })),
        ...passengerSnapshot.docs.map(doc => ({ 
          id: doc.id, 
          ...doc.data(), 
        role: 'passenger'
        }))
      ];

    // Sort by creation time (most recent first)
    rides.sort((a, b) => b.createdAt.toDate() - a.createdAt.toDate());

    return { success: true, rides };
    } catch (error) {
    console.error('Error getting user ride history:', error);
    return { success: false, error: error.message };
  }
};

// Add getMutualFriends function
const getMutualFriends = async (userId1, userId2) => {
  try {
    // Get all friends of user1
    const user1FriendsQuery = query(
      collection(db, 'relationships'),
      where('users', 'array-contains', userId1),
      where('status', '==', 'active'),
      where('type', '==', 'friend')
    );

    // Get all friends of user2
    const user2FriendsQuery = query(
      collection(db, 'relationships'),
      where('users', 'array-contains', userId2),
      where('status', '==', 'active'),
      where('type', '==', 'friend')
    );

    // Get both friend lists
    const [user1Snapshot, user2Snapshot] = await Promise.all([
      getDocs(user1FriendsQuery),
      getDocs(user2FriendsQuery)
    ]);

    // Get friend IDs for both users
    const user1FriendIds = user1Snapshot.docs.map(doc => {
      const data = doc.data();
      return data.users.find(id => id !== userId1);
    });

    const user2FriendIds = user2Snapshot.docs.map(doc => {
      const data = doc.data();
      return data.users.find(id => id !== userId2);
    });

    // Find mutual friends (intersection of both friend lists)
    const mutualFriendIds = user1FriendIds.filter(id => user2FriendIds.includes(id));

    // Get profiles for mutual friends
    const mutualFriends = await Promise.all(
      mutualFriendIds.map(async (friendId) => {
        const userDoc = await getDoc(doc(db, 'users', friendId));
        if (!userDoc.exists()) return null;
        
        const userData = userDoc.data();
          return {
          id: friendId,
          displayName: userData.profile.displayName,
          photoURL: userData.profile.photoURL,
          isOnline: userData.isOnline,
          lastSeen: userData.lastSeen
        };
      })
    );

    // Filter out any null profiles (deleted users)
    const validMutualFriends = mutualFriends.filter(friend => friend !== null);

    return { 
      success: true, 
      mutualFriends: validMutualFriends 
    };
  } catch (error) {
    console.error('Error getting mutual friends:', error);
    return { success: false, error: error.message };
  }
};

// Define the test function
const testFriendRequestsAccess = async () => {
  try {
    console.log('=== Testing Friend Requests Access ===');
    const db = getFirestore();
    const auth = getAuth();
    const user = auth.currentUser;
    
    if (!user) {
      console.error('No authenticated user found');
      return false;
    }

    console.log('Current user:', {
      uid: user.uid,
      email: user.email,
      displayName: user.displayName,
      photoURL: user.photoURL
    });

    // Test 1: Try to create a minimal document first
    console.log('\nTest 1: Creating minimal document...');
    const minimalDocRef = doc(collection(db, 'friendRequests'));
    const minimalData = {
      senderId: user.uid.trim(),  // Ensure no extra spaces
      receiverId: 'tz9KYTQbvtOZ9MQ5S1VdEYrpck83',
      message: 'test'
    };

    console.log('Sending minimal data:', {
      ...minimalData,
      uidComparison: {
        authUid: user.uid.trim(),
        senderId: minimalData.senderId.trim(),
        areEqual: user.uid.trim() === minimalData.senderId.trim()
      }
    });

    try {
      await setDoc(minimalDocRef, minimalData);
      console.log('Minimal document created successfully');
      await deleteDoc(minimalDocRef);
      console.log('Minimal document deleted');
    } catch (minimalError) {
      console.error('Minimal document test failed:', {
        code: minimalError.code,
        message: minimalError.message,
        details: minimalError
      });
    }

    // If minimal test fails, don't proceed with full test
    if (minimalError) {
      return false;
    }

    // Get user profile data first
    const userDoc = await getDoc(doc(db, 'users', user.uid));
    if (!userDoc.exists()) {
      console.error('Current user profile not found in database');
      return false;
    }

    const userData = userDoc.data();
    console.log('User profile data:', {
      id: userDoc.id,
      exists: userDoc.exists(),
      data: userData,
      hasProfile: !!userData.profile,
      hasSettings: !!userData.settings,
      hasReputation: !!userData.reputation
    });

    // Verify user data structure
    if (!userData.profile || !userData.settings || !userData.reputation) {
      console.error('User profile data is incomplete:', {
        hasProfile: !!userData.profile,
        hasSettings: !!userData.settings,
        hasReputation: !!userData.reputation
      });
      return false;
    }

    const friendRequestsRef = collection(db, 'friendRequests');
    
    // Test 2: Try to read requests where user is sender
    console.log('\nTest 2: Reading sent requests...');
    const sentRequestsQuery = query(
      friendRequestsRef,
      where('senderId', '==', user.uid),
      limit(1)
    );
    const sentRequestsSnapshot = await getDocs(sentRequestsQuery);
    console.log('Sent requests test result:', {
      success: true,
      empty: sentRequestsSnapshot.empty,
      size: sentRequestsSnapshot.size,
      docs: sentRequestsSnapshot.docs.map(doc => ({
        id: doc.id,
        exists: doc.exists(),
        data: doc.data()
      }))
    });

    // Test 3: Try to read requests where user is receiver
    console.log('\nTest 3: Reading received requests...');
    const receivedRequestsQuery = query(
      friendRequestsRef,
      where('receiverId', '==', user.uid),
      limit(1)
    );
    const receivedRequestsSnapshot = await getDocs(receivedRequestsQuery);
    console.log('Received requests test result:', {
      success: true,
      empty: receivedRequestsSnapshot.empty,
      size: receivedRequestsSnapshot.size,
      docs: receivedRequestsSnapshot.docs.map(doc => ({
        id: doc.id,
        exists: doc.exists(),
        data: doc.data()
      }))
    });

    // Get a valid receiver ID from the users collection
    console.log('\nGetting a valid receiver ID...');
    const usersQuery = query(
      collection(db, 'users'),
      where('__name__', '!=', user.uid),  // Exclude current user
      limit(1)
    );
    const usersSnapshot = await getDocs(usersQuery);
    
    if (usersSnapshot.empty) {
      console.error('No other users found in the database');
      return false;
    }

    const receiverDoc = usersSnapshot.docs[0];
    const receiverId = receiverDoc.id;
    const receiverData = receiverDoc.data();
    
    // Verify receiver data structure
    console.log('Found receiver:', {
      id: receiverId,
      exists: receiverDoc.exists(),
      data: receiverData,
      hasProfile: !!receiverData.profile,
      hasSettings: !!receiverData.settings,
      hasReputation: !!receiverData.reputation
    });

    if (!receiverData.profile || !receiverData.settings || !receiverData.reputation) {
      console.error('Receiver profile data is incomplete:', {
        hasProfile: !!receiverData.profile,
        hasSettings: !!receiverData.settings,
        hasReputation: !!receiverData.reputation
      });
      return false;
    }

    // Test 4: Try to create a test document
    console.log('\nTest 4: Creating test document...');
    const testDocRef = doc(collection(db, 'friendRequests'));
    const testData = {
      senderId: user.uid,
      receiverId: receiverId,
      message: 'Test friend request',
      senderProfile: {
        displayName: userData.profile.displayName || user.displayName || 'Test User',
        photoURL: userData.profile.photoURL || user.photoURL || '',
        email: userData.profile.email || user.email || ''
      },
      metadata: {
        status: 'pending',
        createdBy: user.uid,
        createdAt: new Date().toISOString()
      }
    };

    // Log the exact data being sent
    console.log('Test data validation:', {
      hasSenderId: typeof testData.senderId === 'string',
      hasReceiverId: typeof testData.receiverId === 'string',
      hasMessage: typeof testData.message === 'string',
      hasMetadata: testData.metadata && typeof testData.metadata === 'object',
      hasValidMetadata: testData.metadata && 
                       testData.metadata.status === 'pending' &&
                       testData.metadata.createdBy === user.uid,
      hasSenderProfile: testData.senderProfile && typeof testData.senderProfile === 'object',
      hasValidProfile: testData.senderProfile &&
                      typeof testData.senderProfile.displayName === 'string' &&
                      typeof testData.senderProfile.photoURL === 'string' &&
                      typeof testData.senderProfile.email === 'string',
      senderMatchesAuth: testData.senderId === user.uid,
      notSelfRequest: testData.senderId !== testData.receiverId,
      senderProfileData: {
        displayName: testData.senderProfile.displayName,
        photoURL: testData.senderProfile.photoURL,
        email: testData.senderProfile.email
      }
    });

    console.log('Sending data:', JSON.stringify(testData, null, 2));

    try {
      await setDoc(testDocRef, testData);
      console.log('Write test successful:', {
        docId: testDocRef.id,
        data: testData
      });

      // Test 5: Try to read the created document
      console.log('\nTest 5: Reading created document...');
      const createdDoc = await getDoc(testDocRef);
      console.log('Read created document result:', {
        success: createdDoc.exists(),
        data: createdDoc.exists() ? createdDoc.data() : null
      });

      // Clean up: Delete the test document
      console.log('\nCleaning up: Deleting test document...');
      await deleteDoc(testDocRef);
      console.log('Test document deleted successfully');
      
      return true;
    } catch (writeError) {
      console.error('Write test failed:', {
        code: writeError.code,
        message: writeError.message,
        details: writeError,
        data: testData,
        validation: {
          senderProfile: testData.senderProfile,
          metadata: testData.metadata,
          auth: {
            uid: user.uid,
            email: user.email
          }
        }
      });
      return false;
    }
  } catch (error) {
    console.error('Access test failed:', {
      code: error.code,
      message: error.message,
      details: error
    });
    return false;
  }
};

// Make it available globally for testing
if (typeof window !== 'undefined') {
  window.testFriendRequestsAccess = testFriendRequestsAccess;
}

// Ride Invitation Operations
const sendRideInvitation = async (rideId, inviterId, inviteeId) => {
  try {
    console.log('Sending ride invitation:', { rideId, inviterId, inviteeId });
    
    // Get inviter details
    const inviterDoc = await getDoc(doc(db, 'users', inviterId));
    if (!inviterDoc.exists()) {
      throw new Error('Inviter not found');
    }
    
    const inviterData = inviterDoc.data();
    
    // Get ride details
    const rideDoc = await getDoc(doc(db, 'rides', rideId));
    if (!rideDoc.exists()) {
      throw new Error('Ride not found');
    }
    
    const rideData = rideDoc.data();
    
    // Create invitation data
    const invitationData = {
      status: 'pending',
      inviter: {
        uid: inviterId,
        displayName: inviterData.profile?.displayName || inviterData.displayName,
        photoURL: inviterData.profile?.photoURL || inviterData.photoURL,
        email: inviterData.profile?.email || inviterData.email
      },
      invitedAt: serverTimestamp(),
      rideId: rideId,
      rideDestination: rideData.destination?.address || 'Unknown destination',
      rideDate: rideData.createdAt
    };
    
    // Add invitation to ride document
    const rideRef = doc(db, 'rides', rideId);
    await updateDoc(rideRef, {
      [`invitations.${inviteeId}`]: invitationData,
      updatedAt: serverTimestamp()
    });
    
    // Create notification for invitee
    await createNotification({
      userId: inviteeId,
      type: 'ride-invitation',
      title: 'Ride Invitation',
      message: `${inviterData.profile?.displayName || inviterData.displayName} invited you to join their ride`,
      metadata: {
        rideId: rideId,
        inviterId: inviterId,
        inviterName: inviterData.profile?.displayName || inviterData.displayName,
        inviterPhotoURL: inviterData.profile?.photoURL || inviterData.photoURL,
        destination: rideData.destination?.address || 'Unknown destination'
      },
      actionUrl: `/rides/${rideId}`
    });
    
    console.log('Ride invitation sent successfully');
    return { 
      success: true, 
      invitationId: `${rideId}_${inviteeId}`,
      message: 'Invitation sent successfully'
    };
  } catch (error) {
    console.error('Error sending ride invitation:', error);
    return { success: false, error: error.message };
  }
};

const deleteRideInvitation = async ({ rideId, inviteeId }) => {
  try {
    console.log('Deleting ride invitation:', { rideId, inviteeId });
    
    const rideRef = doc(db, 'rides', rideId);
    await updateDoc(rideRef, {
      [`invitations.${inviteeId}`]: deleteField(),
      updatedAt: serverTimestamp()
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error deleting ride invitation:', error);
    return { success: false, error: error.message };
  }
};

const respondToRideInvitation = async (rideId, inviteeId, response, details = {}) => {
  try {
    console.log('Responding to ride invitation:', { rideId, inviteeId, response, details });
    
    const rideRef = doc(db, 'rides', rideId);
    const rideDoc = await getDoc(rideRef);
    
    if (!rideDoc.exists()) {
      throw new Error('Ride not found');
    }
    
    const rideData = rideDoc.data();
    const invitation = rideData.invitations?.[inviteeId];
    
    if (!invitation) {
      throw new Error('Invitation not found');
    }
    
    // Update invitation status
    const updateData = {
      [`invitations.${inviteeId}.status`]: response,
      [`invitations.${inviteeId}.respondedAt`]: serverTimestamp(),
      updatedAt: serverTimestamp()
    };
    
    // If accepted, add details
    if (response === 'accepted' && details) {
      updateData[`invitations.${inviteeId}.details`] = {
        pickupLocation: details.pickupLocation || null,
        role: details.role || 'passenger',
        readyTime: details.readyTime || null,
        locationSharing: details.locationSharing || false,
        notes: details.notes || ''
      };
      
      // Add user to ride participants
      updateData[`participants.${inviteeId}`] = {
        role: details.role || 'passenger',
        status: 'confirmed',
        joinedAt: serverTimestamp(),
        pickupLocation: details.pickupLocation || null,
        readyTime: details.readyTime || null,
        locationSharing: details.locationSharing || false
      };
    }
    
    await updateDoc(rideRef, updateData);
    
    // Create notification for inviter
    const inviteeDoc = await getDoc(doc(db, 'users', inviteeId));
    const inviteeData = inviteeDoc.exists() ? inviteeDoc.data() : {};
    const inviteeName = inviteeData.profile?.displayName || inviteeData.displayName || 'Someone';
    
    await createNotification({
      userId: invitation.inviter.uid,
      type: 'ride-invitation-response',
      title: 'Ride Invitation Response',
      message: `${inviteeName} ${response} your ride invitation`,
      metadata: {
        rideId: rideId,
        inviteeId: inviteeId,
        inviteeName: inviteeName,
        response: response,
        destination: rideData.destination?.address || 'Unknown destination'
      },
      actionUrl: `/rides/${rideId}`
    });
    
    console.log('Ride invitation response processed successfully');
    return { success: true, message: `Invitation ${response} successfully` };
  } catch (error) {
    console.error('Error responding to ride invitation:', error);
    return { success: false, error: error.message };
  }
};

// At the end of the file, update the export statement:
export {
  // User Operations
  createUserProfile,
  updateUserProfile,
  updateUserLocation,
  updateUserOnlineStatus,
  updateUserSettings,
  updateUserReputation,

  // Group Operations
  createGroup,
  updateGroup,

  // Ride Operations
  createRide,
  updateRide,
  updateRideParticipation,

  // Friend Operations
  sendFriendRequest,
  updateFriendRequest,
  getFriendsList,
  updateRelationshipCommunity,
  removeFriendship,
  checkFriendshipStatus,

  // Subscription Operations
  subscribeToFriendRequests,
  subscribeToFriendsList,
  subscribeToUserStatus,

  // Message and Notification Operations
  sendMessage,
  createNotification,

  // Search Operations
  searchUsers,

  // New function
  getUserRideHistory,

  // New function
  getMutualFriends,

  // New function
  testFriendRequestsAccess,

  // Ride Invitation Operations
  sendRideInvitation,
  deleteRideInvitation,
  respondToRideInvitation
}; 